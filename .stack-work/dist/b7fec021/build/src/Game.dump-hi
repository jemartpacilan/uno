
==================== FINAL INTERFACE ====================
2016-12-23 12:03:51.1464691 UTC

interface uno-0.1.1-9oZSbbIzoKW1G8tXby6amp:Game 8001
  interface hash: fc212bec4d5d607ad1e71f52ea506932
  ABI hash: b679210a528f617b27e2bd7c3bc1478a
  export-list hash: ff2db2e9062ded0783a0f1e3c965a11e
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 365edb496d38399416a64131c77130e2
  sig of: Nothing
  used TH splices: False
  where
exports:
  Game.attackAndPlay
  Game.cardCanPlay
  Game.cardInCurHand
  Game.cardInHand
  Game.check
  Game.curHand
  Game.deal
  Game.deckIsEmpty
  Game.discard
  Game.discardCards
  Game.drawAndEnd
  Game.drawNCards
  Game.getNextPlayer
  Game.initGame
  Game.initGameWithPlayers
  Game.initialCardCount
  Game.pickNextAndPlay
  Game.pickNextPlayer
  Game.playCard
  Game.playCurrentPlayer
  Game.playLoop
  Game.playLoopNext
  Game.playOneCard
  Game.playPlayer
  Game.playTurn
  Game.playerHasWon
  Game.playerIsOut
  Game.reloadDeck
  Game.restartGame
  Game.reverseAndPlay
  Game.reversePlayers
  Game.setupGame
  Game.startGame
  Game.takeAction
  Game.takeFromDeck
  Game.takeFromHand
  Game.takeFromHandWithAction
  Game.takeNextAction
  Game.topDCard
  Game.updateCurHand
  Game.updateCurPlayer
  Game.updateDeck
  Game.updateDiscardS
  Game.updateHand
  Game.updatePlayer
  Game.useSimpleStrategy
module dependencies: Common Shuffler
package dependencies: MonadRandom-0.4.2.3@MonadRandom-0.4.2.3-8TfCm6PGvGYB7omozORhov
                      Win32-2.3.1.1@Win32-2.3.1.1
                      ansi-terminal-0.6.2.3@ansi-terminal-0.6.2.3-DlzOk98pOsTIrg6vAjszFA
                      array-0.5.1.1@array-0.5.1.1 base-4.9.0.0*
                      deepseq-1.4.2.0@deepseq-1.4.2.0 ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1 mtl-2.2.1@mtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM
                      random-1.1@random-1.1-54KmMHXjttlERYcr1mvsAe
                      random-shuffle-0.0.4@random-shuffle-0.0.4-LfeDYNPfwrQ2o9p6tw2M9l
                      time-1.6.0.1@time-1.6.0.1 transformers-0.5.2.0@transformers-0.5.2.0
orphans: MonadRandom-0.4.2.3@MonadRandom-0.4.2.3-8TfCm6PGvGYB7omozORhov:Control.Monad.Random
         base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
         time-1.6.0.1@time-1.6.0.1:Data.Time.Calendar.Gregorian
         time-1.6.0.1@time-1.6.0.1:Data.Time.Format.Parse
         time-1.6.0.1@time-1.6.0.1:Data.Time.LocalTime.LocalTime
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Complex base-4.9.0.0:Data.Either
                         base-4.9.0.0:Data.Functor.Const base-4.9.0.0:Data.Functor.Identity
                         base-4.9.0.0:Data.List.NonEmpty base-4.9.0.0:Data.Monoid
                         base-4.9.0.0:Data.Semigroup base-4.9.0.0:Data.Type.Equality
                         base-4.9.0.0:Data.Version base-4.9.0.0:Data.Void
                         base-4.9.0.0:GHC.Exts base-4.9.0.0:GHC.Generics
                         base-4.9.0.0:GHC.IO.Exception base-4.9.0.0:GHC.TypeLits
import  -/  ansi-terminal-0.6.2.3@ansi-terminal-0.6.2.3-DlzOk98pOsTIrg6vAjszFA:System.Console.ANSI ca076ca422c52166e42be1349b9453ba
import  -/  ansi-terminal-0.6.2.3@ansi-terminal-0.6.2.3-DlzOk98pOsTIrg6vAjszFA:System.Console.ANSI.Common 120534aeddf149317cb5216a438351ac
import  -/  base-4.9.0.0:Data.Foldable 3cbed01c922be29649c33015287c82ca
import  -/  base-4.9.0.0:Data.List d711f98b49ef5d33e5b3d404631ed073
import  -/  base-4.9.0.0:Data.Maybe 086a84053ef7f7810663b5f03b7ec3f7
import  -/  base-4.9.0.0:GHC.Base dd8044a8d640eee51828c17c476a6ba7
import  -/  base-4.9.0.0:GHC.Err 20faef8829fd13c027d0ee2213637534
import  -/  base-4.9.0.0:GHC.List 47d436dfb7454bb1883fb4d943e3f389
import  -/  base-4.9.0.0:GHC.Num f0aed3315b3ed1b330b71fc4148a5581
import  -/  base-4.9.0.0:GHC.Show 0b5845243cb2ec62b57dd6963d276ec6
import  -/  base-4.9.0.0:Prelude 2d9cd8b0ec3d728f62b734df888d2e34
import  -/  ghc-prim-0.5.0.0:GHC.Classes 16d48e012d23eaef9bca91ccdd572c02
import  -/  ghc-prim-0.5.0.0:GHC.Types 7378e41b7749213c8c88ceb6b0665d4c
import  -/  Common b12506011c6a950a79af89a87031a868
  exports: 1ce0f192f1e4af6fef4b0f2681389940
  Action 76a923cef3461a90e7a7daf7e02a004b
  Attack c43f46aefeb40b09aa7dd66d99e75254
  AttackDraw2 cf915a6c575f296d50d8a762a188bbf6
  AttackReverse 1cc05bca4d3f2f2dff150d8436803fb2
  AttackSkip 3a8b480adbb04c03d660d60d3e0c9780
  AttackWildDraw4 7f371afe860959a0e0abab8e72cf5d93
  Card d3655a4ec5691a261211acc68543f755
  ChCol 5dcc5fafe7b5d5fd84c8b6a26ffe9a9c
  ChDir 79caf763c07e0ad8e3fd8dcfa4ab71c1
  Deck 464f829e85e2d8956a692498bb672e82
  Draw2 d964fa850df0fa0eb45cf08adb87d35a
  Draw4 e509d9505248fb3953fc47ad4e73848e
  EndTurn a4cd237d6dca2291619e6b9a5c10d7b7
  HPlayer c2dc083fa9a7b446d47c908179021218
  Hand 36ab7f9974a0abf23a6627c072079a47
  NoAttack 667fa24bde48d3e709ccd37a90c094c3
  NoPlayer 1350b161884b9aedf06d7d8ef590017b
  Player d4359d9a5d6ba4060bfb794b279f6a73
  Plus2 dad10bbc8fca2f7c81cb2ec0ee41c062
  Plus4 fa253e2d6679d9c43e0ba4e435ca2842
  Skip 646658e65d597f0c074b55dea82750af
  State 92510974a9edbf1081f2f2e4b5eddcfb
  State 2557980be5241c48c15a145621c2a18e
  Stop 6c005190a13b0d9808e097fe51c279ed
  TakeFromDeck 3171f456c7212be8e1d72d304fae575c
  UseCard 9833f87f4b54b1ca490b5b28c125cbcb
  clearHands 0fae7421de6aea151354d13b27e24f74
  color aecc4aefc44587057e99e9b76aea34d1
  colorBlack 3403ae252e5b06441b9ccb31f103bc3c
  countCardsByColor 08ff3e6ebdf224196c84efcc095ca610
  cur_player 1999cb17dece5d16d43f483b47a586ff
  d_stack 52e4815f951ab775ced38acfc3007872
  deck 86901041458ce52a067f6fc410e8bb9e
  e_players de1169e4f6a9341c3c941706942b1b9b
  fullDeck 517fe5913b7f3770199b103f6625add4
  getCardWithColor 77d983421891cd6180e854282fc85c46
  getCardWithValue 4996ca4a9b88442aca4bebd0bfd6ba58
  getWildcard f7147929c52fbc2e31cc197dbb6cf3da
  hand 406367828e9503cc75d4ea73285c6451
  isChangeColCards d06834b44e492cf5cf5ccb4731688d10
  isNumberCard 109344a9d1a0bea0abcccdf568652ee0
  isWildcard e89fbcd31d78a19631add8550e115a5e
  name 47e7484b9af632a1a3aca30447099ee6
  noCard d454b79d092a482a5f3a474bfbdcb8ff
  noPlayer 1f6ad14673a8ad50f1f02628c21f7ed8
  players 4b044af41c7915cda41aa6fcaaba6062
  takeCards f3641d2b18d19cfa860b0a77edf41901
  value d10b884ee7f0ec75f0a11e8b7dc592fc
  valueInHand f09a520dddfd04b086cf40fa1714233e
  wildcardInHand 7fc7a8f4a23b07bef3d28e5f20b74ea3
import  -/  Shuffler 7f6a403d6f2b1b3d45d4610b24507492
  exports: f6285404716573b527204386263a7d42
  shuffleDeck 4c03edb9114b69c0adb417e5be1e2c1c
60c960654e42fd0d26dc711abbe67448
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Game.$trModule2 Game.$trModule1) -}
753b35286e5fa289ea7ad1e7d10cdc3a
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Game"#) -}
941a7abcf27528466f6296f7c0541402
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "uno-0.1.1-9oZSbbIzoKW1G8tXby6amp"#) -}
3010ab82d45f0ee1645711da2ba1b78b
  $winitGame ::
    GHC.Types.Int
    -> (# [Common.Player], [Common.Player], Common.Deck,
          Common.D_Stack, Common.Player #)
  {- Arity: 1, Strictness: <L,1*U(U)>, Inline: [0],
     Unfolding: (\ (w :: GHC.Types.Int) ->
                 (# case w of wild1 { GHC.Types.I# y ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.># 1# y) of wild {
                      GHC.Types.False
                      -> letrec {
                           go :: GHC.Prim.Int# -> [Common.Player]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ (x :: GHC.Prim.Int#) ->
                             GHC.Types.:
                               @ Common.Player
                               (Common.HPlayer
                                  (GHC.CString.unpackAppendCString#
                                     "Player"#
                                     (case GHC.Show.$wshowSignedInt
                                             0#
                                             x
                                             (GHC.Types.[]
                                                @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                                      GHC.Types.: @ GHC.Types.Char ww5 ww6 }))
                                  (GHC.Types.[] @ Common.Card))
                               (case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.==# x y) of wild2 {
                                  GHC.Types.False -> go (GHC.Prim.+# x 1#)
                                  GHC.Types.True -> GHC.Types.[] @ Common.Player })
                         } in
                         go 1#
                      GHC.Types.True -> GHC.Types.[] @ Common.Player } },
                    GHC.Types.[] @ Common.Player, Common.fullDeck,
                    GHC.Types.[] @ Common.Card, Common.noPlayer #)) -}
465d8128ca3a06f124f207a83913622f
  $wpickNextAndPlay ::
    [Common.Player]
    -> [Common.Player]
    -> Common.Deck
    -> Common.D_Stack
    -> Common.Player
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Common.State #)
  {- Arity: 6, Strictness: <S,U><L,U><L,U><L,U><S,1*U><S,U>,
     Inline: [0],
     Unfolding: (\ (ww :: [Common.Player])
                   (ww1 :: [Common.Player])
                   (ww2 :: Common.Deck)
                   (ww3 :: Common.D_Stack)
                   (ww4 :: Common.Player)
                   (w :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 Game.$wplayLoop
                   ww
                   ww1
                   ww2
                   ww3
                   (Game.check ww ww4)
                   Common.NoAttack
                   w) -}
050d9fede5cc2dc52e261948ab4d71f5
  $wplayCard ::
    System.Console.ANSI.Common.Color
    -> Common.Value
    -> Common.State
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (Common.Action, Common.State) #)
  {- Arity: 4, Strictness: <S,U><L,U><L,U(U,U,U,U,U)><S,U>,
     Inline: [0],
     Unfolding: (\ (ww :: System.Console.ANSI.Common.Color)
                   (ww1 :: Common.Value)
                   (w :: Common.State)
                   (w1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case ww of wild {
                   DEFAULT
                   -> let {
                        wild1 :: Common.Card = Common.Card wild ww1
                      } in
                      case GHC.Prim.dataToTag# @ Common.Value ww1 of wild2 {
                        DEFAULT
                        -> case GHC.List.elem
                                  @ Common.Card
                                  Common.$fEqCard
                                  wild1
                                  Common.numberCards of wild3 {
                             GHC.Types.False
                             -> case Game.playCard3
                                ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                          (Common.Action, Common.State) #)
                                of {}
                             GHC.Types.True
                             -> case Game.playCard2 wild1 w w1 of ds1 { (#,#) ipv ipv1 ->
                                (# ipv, (Common.EndTurn, ipv1) #) } }
                        10#
                        -> case Game.playCard2 wild1 w w1 of ds1 { (#,#) ipv ipv1 ->
                           (# ipv, (Common.AttackDraw2, ipv1) #) }
                        11#
                        -> case Game.playCard2 wild1 w w1 of ds1 { (#,#) ipv ipv1 ->
                           (# ipv, (Common.AttackSkip, ipv1) #) }
                        12#
                        -> case Game.playCard2 wild1 w w1 of ds1 { (#,#) ipv ipv1 ->
                           (# ipv, (Common.AttackReverse, ipv1) #) }
                        13#
                        -> case Game.playCard2 wild1 w w1 of ds1 { (#,#) ipv ipv1 ->
                           (# ipv, (Common.AttackWildDraw4, ipv1) #) }
                        14#
                        -> case Game.playCard2 wild1 w w1 of ds1 { (#,#) ipv ipv1 ->
                           (# ipv, (Common.EndTurn, ipv1) #) } }
                   System.Console.ANSI.Common.White
                   -> (# w1, (Common.EndTurn, w) #) }) -}
89091acd2b0c79f95ab280f298e5a591
  $wplayLoop ::
    [Common.Player]
    -> [Common.Player]
    -> Common.Deck
    -> Common.D_Stack
    -> Common.Player
    -> Common.Attack
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Common.State #)
  {- Arity: 7, Strictness: <L,U><L,U><L,U><L,U><S,U><L,1*U><S,U>,
     Inline: [0] -}
559de6ab1cf3d751ead254a682d0e17f
  $wplayLoopNext ::
    [Common.Player]
    -> [Common.Player]
    -> Common.Deck
    -> Common.D_Stack
    -> Common.Player
    -> Common.Action
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Common.State #)
  {- Arity: 7, Strictness: <S,U><L,U><L,U><L,U><S,1*U><S,1*U><S,U>,
     Inline: [0] -}
4a89006d7a76b065bd58e123daf20f40
  $wplayOneCard ::
    [Common.Player]
    -> [Common.Player]
    -> Common.Deck
    -> Common.D_Stack
    -> Common.Player
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (Common.Action, Common.State) #)
  {- Arity: 6, Strictness: <L,U><L,U><L,U><L,U><S,U><S,U>,
     Inline: [0],
     Unfolding: (\ (ww :: [Common.Player])
                   (ww1 :: [Common.Player])
                   (ww2 :: Common.Deck)
                   (ww3 :: Common.D_Stack)
                   (ww4 :: Common.Player)
                   (w :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case ww4 of wild {
                   Common.HPlayer ds1 ds2
                   -> case Game.$wuseSimpleStrategy
                             (Game.cardCanPlay_go ww3 (GHC.List.lastError @ Common.Card))
                             ds2 of ww5 { (#,#) ww6 ww7 ->
                      Game.playOneCard2 ww6 ww7 (Common.State ww ww1 ww2 ww3 wild) w }
                   Common.AiPlayer ds1 ds2
                   -> case Game.$wuseSimpleStrategy
                             (Game.cardCanPlay_go ww3 (GHC.List.lastError @ Common.Card))
                             ds2 of ww5 { (#,#) ww6 ww7 ->
                      Game.playOneCard2 ww6 ww7 (Common.State ww ww1 ww2 ww3 wild) w }
                   Common.NoPlayer ipv
                   -> case Common.hand1
                      ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                (Common.Action, Common.State) #)
                      of {} }) -}
7cdddf4bef105e24e22f9f7d966a811d
  $wplayerHasWon :: Common.Player -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ (ww :: Common.Player) ->
                 case ww of wild {
                   Common.HPlayer ds1 ds2
                   -> GHC.Classes.$fEq[]_$c==
                        @ Common.Card
                        Common.$fEqCard
                        ds2
                        (GHC.Types.[] @ Common.Card)
                   Common.AiPlayer ds1 ds2
                   -> GHC.Classes.$fEq[]_$c==
                        @ Common.Card
                        Common.$fEqCard
                        ds2
                        (GHC.Types.[] @ Common.Card)
                   Common.NoPlayer ipv
                   -> case Common.hand1 ret_ty GHC.Types.Bool of {} }) -}
190062c118edc93d6f58b8dff401aad0
  $wreverseAndPlay ::
    [Common.Player]
    -> [Common.Player]
    -> Common.Deck
    -> Common.D_Stack
    -> Common.Player
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Common.State #)
  {- Arity: 6, Strictness: <S,1*U><L,U><L,U><L,U><S,1*U><S,U>,
     Inline: [0],
     Unfolding: (\ (ww :: [Common.Player])
                   (ww1 :: [Common.Player])
                   (ww2 :: Common.Deck)
                   (ww3 :: Common.D_Stack)
                   (ww4 :: Common.Player)
                   (w :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 let {
                   ds :: [Common.Player]
                   = GHC.List.reverse1
                       @ Common.Player
                       ww
                       (GHC.Types.[] @ Common.Player)
                 } in
                 Game.$wplayLoop
                   ds
                   ww1
                   ww2
                   ww3
                   (Game.check ds ww4)
                   Common.NoAttack
                   w) -}
076ac6ef104cbc15b3af89f48e6c7331
  $wsetupGame ::
    [Common.Player]
    -> [Common.Player]
    -> Common.Deck
    -> Common.D_Stack
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Common.State #)
  {- Arity: 5, Strictness: <L,1*U><L,U><S,U><L,1*U><S,U>,
     Inline: [0],
     Unfolding: (\ (ww :: [Common.Player])
                   (ww1 :: [Common.Player])
                   (ww2 :: Common.Deck)
                   (ww3 :: Common.D_Stack)
                   (w :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case (System.Random.Shuffle.shuffleM
                         @ GHC.Types.IO
                         @ Common.Card
                         Control.Monad.Random.$fMonadRandomIO
                         (Game.$wunsafeDrop2 @ Common.Card 29# ww2))
                        `cast`
                      (GHC.Types.N:IO[0] <[Common.Card]>_R)
                        w of ds7 { (#,#) ipv ipv1 ->
                 (# ipv,
                    Common.State
                      (Game.deal ww2 ww)
                      ww1
                      ipv1
                      (Game.discard ww3 ww2)
                      Common.noPlayer #) }) -}
357efd78271dd65104fce56572419e06
  $wtopDCard :: Common.D_Stack -> Common.Card
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ (ww :: Common.D_Stack) ->
                 Game.cardCanPlay_go ww (GHC.List.lastError @ Common.Card)) -}
ab15efc11bd16716831b7cb74cfe7ae4
  $wunsafeDrop :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [0] -}
a5d3516d71c414620207c914687f064f
  $wunsafeDrop1 :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [0] -}
713e4befa12b8e1b1fb4722bb641c08c
  $wunsafeDrop2 :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [0] -}
8d01103a09991c042cd272a874d54638
  $wuseSimpleStrategy ::
    Common.Card -> Common.Hand -> (# Common.Action, Common.Card #)
  {- Arity: 2, Strictness: <L,U(U,U)><S,U>, Inline: [0],
     Unfolding: (\ (w :: Common.Card) (w1 :: Common.Hand) ->
                 case Common.$wcountCardsByColor
                        (Common.color w)
                        w1 of ww { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># ww 0#) of wild {
                   GHC.Types.False
                   -> case (Common.valueInHand1 (Common.value w) w1)
                             `cast`
                           (Data.Monoid.N:Any[0]) of wild1 {
                        GHC.Types.False
                        -> case (Common.wildcardInHand_go w1)
                                  `cast`
                                (Data.Monoid.N:Any[0]) of wild2 {
                             GHC.Types.False -> (# Common.TakeFromDeck, Common.whiteDummy #)
                             GHC.Types.True
                             -> (# Common.UseCard,
                                   case (Common.getWildcard_go w1)
                                          `cast`
                                        (Data.Monoid.N:First[0] <Common.Card>_N) of wild3 {
                                     GHC.Base.Nothing -> Data.Maybe.fromJust1 @ Common.Card
                                     GHC.Base.Just x -> x } #) }
                        GHC.Types.True
                        -> (# Common.UseCard,
                              case (Common.getCardWithValue1 (Common.value w) w1)
                                     `cast`
                                   (Data.Monoid.N:First[0] <Common.Card>_N) of wild2 {
                                GHC.Base.Nothing -> Data.Maybe.fromJust1 @ Common.Card
                                GHC.Base.Just x -> x } #) }
                   GHC.Types.True
                   -> (# Common.UseCard,
                         case (Common.getCardWithColor1
                                 (case w of wild1 { Common.Card ds1 ds2 -> ds1 })
                                 w1)
                                `cast`
                              (Data.Monoid.N:First[0] <Common.Card>_N) of wild1 {
                           GHC.Base.Nothing -> Data.Maybe.fromJust1 @ Common.Card
                           GHC.Base.Just x -> x } #) } }) -}
7e479fd4a4c69eb626c6e74d87ce3a21
  attackAndPlay ::
    Common.State -> Common.Attack -> GHC.Types.IO Common.State
  {- Arity: 3, Strictness: <S(SLLLS),1*U(U,U,U,U,1*U)><L,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Game.attackAndPlay1
                  `cast`
                (<Common.State>_R
                 ->_R <Common.Attack>_R
                 ->_R Sym (GHC.Types.N:IO[0] <Common.State>_R)) -}
30ecdac31a06f751e0dd8faeb7daf512
  attackAndPlay1 ::
    Common.State
    -> Common.Attack
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Common.State #)
  {- Arity: 3, Strictness: <S(SLLLS),1*U(U,U,U,U,1*U)><L,1*U><S,U>,
     Unfolding: InlineRule (3, True, False)
                (\ (gs :: Common.State)
                   (under_attack :: Common.Attack)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case gs of wild { Common.State ds ds1 ds2 ds3 ds4 ->
                 Game.attackAndPlay2
                   (Common.State ds ds1 ds2 ds3 (Game.check ds ds4))
                   under_attack
                   s }) -}
0602f87480990af8b2709f23a86bfff6
  attackAndPlay2 ::
    Common.State
    -> Common.Attack
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Common.State #)
  {- Arity: 3, Strictness: <S(LLLLS),U(U,U,U,U,U)><L,1*U><S,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Common.State)
                   (w1 :: Common.Attack)
                   (w2 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case w of ww { Common.State ww1 ww2 ww3 ww4 ww5 ->
                 Game.$wplayLoop ww1 ww2 ww3 ww4 ww5 w1 w2 }) -}
9414772f91a47f034865b979e8ee9c3c
  cardCanPlay :: Common.Card -> Common.State -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U(U,U)><L,U(A,A,A,U,A)>,
     Unfolding: (\ (card :: Common.Card) (gs :: Common.State) ->
                 case GHC.List.elem
                        @ Common.Card
                        Common.$fEqCard
                        card
                        Common.wildCards of wild {
                   GHC.Types.False
                   -> case GHC.List.elem
                             @ Common.Card
                             Common.$fEqCard
                             card
                             Common.changeColCards of wild1 {
                        GHC.Types.False
                        -> case card of wild2 { Common.Card ds1 ds2 ->
                           case ds1 of wild3 {
                             System.Console.ANSI.Common.Black
                             -> case gs of ww { Common.State ww1 ww2 ww3 ww4 ww5 ->
                                case Game.cardCanPlay_go
                                       ww4
                                       (GHC.List.lastError
                                          @ Common.Card) of wild4 { Common.Card ds4 ds5 ->
                                case ds4 of wild5 {
                                  DEFAULT
                                  -> GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.==#
                                          (GHC.Prim.dataToTag# @ Common.Value ds2)
                                          (GHC.Prim.dataToTag# @ Common.Value ds5))
                                  System.Console.ANSI.Common.Black -> GHC.Types.True } } }
                             System.Console.ANSI.Common.Red
                             -> case gs of ww { Common.State ww1 ww2 ww3 ww4 ww5 ->
                                case Game.cardCanPlay_go
                                       ww4
                                       (GHC.List.lastError
                                          @ Common.Card) of wild4 { Common.Card ds4 ds5 ->
                                case ds4 of wild5 {
                                  DEFAULT
                                  -> GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.==#
                                          (GHC.Prim.dataToTag# @ Common.Value ds2)
                                          (GHC.Prim.dataToTag# @ Common.Value ds5))
                                  System.Console.ANSI.Common.Red -> GHC.Types.True } } }
                             System.Console.ANSI.Common.Green
                             -> case gs of ww { Common.State ww1 ww2 ww3 ww4 ww5 ->
                                case Game.cardCanPlay_go
                                       ww4
                                       (GHC.List.lastError
                                          @ Common.Card) of wild4 { Common.Card ds4 ds5 ->
                                case ds4 of wild5 {
                                  DEFAULT
                                  -> GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.==#
                                          (GHC.Prim.dataToTag# @ Common.Value ds2)
                                          (GHC.Prim.dataToTag# @ Common.Value ds5))
                                  System.Console.ANSI.Common.Green -> GHC.Types.True } } }
                             System.Console.ANSI.Common.Yellow
                             -> case gs of ww { Common.State ww1 ww2 ww3 ww4 ww5 ->
                                case Game.cardCanPlay_go
                                       ww4
                                       (GHC.List.lastError
                                          @ Common.Card) of wild4 { Common.Card ds4 ds5 ->
                                case ds4 of wild5 {
                                  DEFAULT
                                  -> GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.==#
                                          (GHC.Prim.dataToTag# @ Common.Value ds2)
                                          (GHC.Prim.dataToTag# @ Common.Value ds5))
                                  System.Console.ANSI.Common.Yellow -> GHC.Types.True } } }
                             System.Console.ANSI.Common.Blue
                             -> case gs of ww { Common.State ww1 ww2 ww3 ww4 ww5 ->
                                case Game.cardCanPlay_go
                                       ww4
                                       (GHC.List.lastError
                                          @ Common.Card) of wild4 { Common.Card ds4 ds5 ->
                                case ds4 of wild5 {
                                  DEFAULT
                                  -> GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.==#
                                          (GHC.Prim.dataToTag# @ Common.Value ds2)
                                          (GHC.Prim.dataToTag# @ Common.Value ds5))
                                  System.Console.ANSI.Common.Blue -> GHC.Types.True } } }
                             System.Console.ANSI.Common.Magenta
                             -> case gs of ww { Common.State ww1 ww2 ww3 ww4 ww5 ->
                                case Game.cardCanPlay_go
                                       ww4
                                       (GHC.List.lastError
                                          @ Common.Card) of wild4 { Common.Card ds4 ds5 ->
                                case ds4 of wild5 {
                                  DEFAULT
                                  -> GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.==#
                                          (GHC.Prim.dataToTag# @ Common.Value ds2)
                                          (GHC.Prim.dataToTag# @ Common.Value ds5))
                                  System.Console.ANSI.Common.Magenta -> GHC.Types.True } } }
                             System.Console.ANSI.Common.Cyan
                             -> case gs of ww { Common.State ww1 ww2 ww3 ww4 ww5 ->
                                case Game.cardCanPlay_go
                                       ww4
                                       (GHC.List.lastError
                                          @ Common.Card) of wild4 { Common.Card ds4 ds5 ->
                                case ds4 of wild5 {
                                  DEFAULT
                                  -> GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.==#
                                          (GHC.Prim.dataToTag# @ Common.Value ds2)
                                          (GHC.Prim.dataToTag# @ Common.Value ds5))
                                  System.Console.ANSI.Common.Cyan -> GHC.Types.True } } }
                             System.Console.ANSI.Common.White
                             -> case gs of ww { Common.State ww1 ww2 ww3 ww4 ww5 ->
                                case Game.cardCanPlay_go
                                       ww4
                                       (GHC.List.lastError
                                          @ Common.Card) of wild4 { Common.Card ds4 ds5 ->
                                case ds4 of wild5 {
                                  DEFAULT
                                  -> GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.==#
                                          (GHC.Prim.dataToTag# @ Common.Value ds2)
                                          (GHC.Prim.dataToTag# @ Common.Value ds5))
                                  System.Console.ANSI.Common.White -> GHC.Types.True } } } } }
                        GHC.Types.True -> GHC.Types.True }
                   GHC.Types.True -> Game.cardCanPlay1 }) -}
1f1ee737ac1e6c4af7fff257bc57b800
  cardCanPlay1 :: GHC.Types.Bool
  {- Strictness: x -}
eadb10bccc98b8b4b7c6fdd374497c57
  cardCanPlay_go :: [Common.Card] -> Common.Card -> Common.Card
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U(U,U)> -}
25e14504db1923d16f98070567d51ec1
  cardInCurHand :: Common.Card -> Common.State -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U(U,U)><S(LLLLS),1*U(A,A,A,A,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (card :: Common.Card) (gs :: Common.State) ->
                 Game.cardInHand card (Common.cur_player gs)) -}
1386a996864f74ede9cab27bbd0377ef
  cardInHand :: Common.Card -> Common.Player -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U(U,U)><S,1*U> -}
7a91a54091f1a8e89971a2967cc1f4a7
  check :: [Common.Player] -> Common.Player -> Common.Player
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
9f989a83c1845bd909aa8f15e15c3c04
  curHand :: Common.State -> Common.Hand
  {- Arity: 1, Strictness: <S(LLLLS),1*U(A,A,A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (gs :: Common.State) ->
                 case gs of wild { Common.State ds1 ds2 ds3 ds4 ds5 ->
                 case ds5 of wild1 {
                   Common.HPlayer ds7 ds8 -> ds8
                   Common.AiPlayer ds7 ds8 -> ds8
                   Common.NoPlayer ipv -> Common.hand1 } }) -}
35d397ca8cdd9139a22a2a5b5da393bf
  deal :: [Common.Card] -> [Common.Player] -> [Common.Player]
  {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
c3c903e1568cf2b1a10a715385311ded
  deckIsEmpty :: Common.State -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLSLL),1*U(A,A,1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (gs :: Common.State) ->
                 case gs of wild { Common.State ds1 ds2 ds3 ds4 ds5 ->
                 case ds3 of wild1 {
                   [] -> GHC.Types.True : ds7 ds8 -> GHC.Types.False } }) -}
ad696c7c690973c26bc1393f1dd0ccdd
  discard :: [Common.Card] -> [Common.Card] -> [Common.Card]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: [Common.Card]) (ds1 :: [Common.Card]) ->
                 case ds1 of wild {
                   [] -> ds
                   : ipv ipv1
                   -> GHC.Base.augment
                        @ Common.Card
                        (\ @ b (c :: Common.Card -> b -> b)[OneShot] (n :: b)[OneShot] ->
                         GHC.Base.foldr @ Common.Card @ b c n ds)
                        (GHC.List.$wunsafeTake @ Common.Card 1# wild) }) -}
45e68297f219cd91e25fa4ffa8365ba5
  discardCards ::
    [Common.Card] -> Common.State -> GHC.Types.IO Common.State
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U><L,1*U(U,U,U,1*U,U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Game.discardCards1
                  `cast`
                (<[Common.Card]>_R
                 ->_R <Common.State>_R
                 ->_R Sym (GHC.Types.N:IO[0] <Common.State>_R)) -}
c602db51835c38f5224d635c7a164758
  discardCards1 ::
    [Common.Card]
    -> Common.State
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Common.State #)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U><L,1*U(U,U,U,1*U,U)><S,U>,
     Unfolding: InlineRule (3, True, False)
                (\ (cards :: [Common.Card])
                   (gs :: Common.State)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 (# eta,
                    case gs of wild { Common.State ds ds1 ds2 ds3 ds4 ->
                    Common.State
                      ds
                      ds1
                      ds2
                      (GHC.Base.augment
                         @ Common.Card
                         (\ @ b (c :: Common.Card -> b -> b)[OneShot] (n :: b)[OneShot] ->
                          GHC.Base.foldr @ Common.Card @ b c n ds3)
                         cards)
                      ds4 } #)) -}
7c5b521f98e2cf047859f3d0842ceb7e
  drawAndEnd ::
    Common.State
    -> GHC.Types.Int -> GHC.Types.IO (Common.Action, Common.State)
  {- Arity: 3, Strictness: <L,U(U,U,U,U,U)><L,U(U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Game.drawAndEnd1
                  `cast`
                (<Common.State>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (GHC.Types.N:IO[0] <(Common.Action, Common.State)>_R)) -}
6e3690e93edbbc7a96538e40d8b85a50
  drawAndEnd1 ::
    Common.State
    -> GHC.Types.Int
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (Common.Action, Common.State) #)
  {- Arity: 3, Strictness: <L,U(U,U,U,U,U)><L,U(U)><S,U>,
     Unfolding: InlineRule (3, True, False)
                (\ (gs :: Common.State)
                   (draw_count :: GHC.Types.Int)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case Game.drawAndEnd2
                        draw_count
                        gs
                        (case gs of wild { Common.State ds1 ds2 ds3 ds4 ds5 -> ds5 })
                        s of ds1 { (#,#) ipv ipv1 ->
                 (# ipv, (Common.EndTurn, ipv1) #) }) -}
79fb79cd38c56a747fb97a13d10f01af
  drawAndEnd2 ::
    GHC.Types.Int
    -> Common.State
    -> Common.Player
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Common.State #)
  {- Arity: 4, Strictness: <L,U(U)><L,U(1*U,U,U,U,U)><L,U><S,U>,
     Unfolding: (\ (n :: GHC.Types.Int)
                   (gs :: Common.State)
                   (player :: Common.Player)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 let {
                   xs :: [Common.Card]
                   = let {
                       arg :: [Common.Card]
                       = case n of wild1 { GHC.Types.I# y ->
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.<# 0# y) of wild {
                           GHC.Types.False -> GHC.Types.[] @ Common.Card
                           GHC.Types.True
                           -> case gs of wild2 { Common.State ds1 ds2 ds3 ds4 ds5 ->
                              GHC.List.$wunsafeTake @ Common.Card y ds3 } } }
                     } in
                     case player of wild {
                       Common.HPlayer ds1 ds2 -> GHC.Base.++ @ Common.Card ds2 arg
                       Common.AiPlayer ds1 ds2 -> GHC.Base.++ @ Common.Card ds2 arg
                       Common.NoPlayer ipv -> Common.hand1 }
                 } in
                 Game.drawAndEnd4
                   (case gs of wild { Common.State ds ds1 ds2 ds3 ds4 ->
                    Common.State
                      ds
                      ds1
                      (case n of wild1 { GHC.Types.I# x ->
                       case GHC.Prim.tagToEnum#
                              @ GHC.Types.Bool
                              (GHC.Prim.<=# x 0#) of wild2 {
                         GHC.Types.False -> Game.$wunsafeDrop @ Common.Card x ds2
                         GHC.Types.True -> ds2 } })
                      ds3
                      ds4 })
                   player
                   (case player of wild {
                      Common.HPlayer ds ds1 -> Common.HPlayer ds xs
                      Common.AiPlayer ds ds1 -> Common.AiPlayer ds xs
                      Common.NoPlayer ipv -> Game.drawAndEnd3 })
                   eta) -}
2d7fec99778e2871ad3e287ee0f15833
  drawAndEnd3 :: Common.Player
  {- Strictness: x -}
19f7b429ee2bf34da5d29358fad6b613
  drawAndEnd4 ::
    Common.State
    -> Common.Player
    -> Common.Player
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Common.State #)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(1*U,U,U,U,U)><L,U><L,U><S,U>,
     Unfolding: (\ (gs :: Common.State)
                   (p :: Common.Player)
                   (new_p :: Common.Player)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 (# eta,
                    case gs of wild { Common.State ds ds1 ds2 ds3 ds4 ->
                    Common.State
                      (GHC.Base.map
                         @ Common.Player
                         @ Common.Player
                         (\ (p' :: Common.Player) ->
                          case Common.$fEqPlayer_$c== p' p of wild1 {
                            GHC.Types.False -> p' GHC.Types.True -> new_p })
                         ds)
                      ds1
                      ds2
                      ds3
                      (case Common.$fEqPlayer_$c== ds4 p of wild1 {
                         GHC.Types.False -> ds4 GHC.Types.True -> new_p }) } #)) -}
df914c258e205dad49dcfcfb5e38eab1
  drawNCards ::
    GHC.Types.Int
    -> Common.State -> Common.Player -> GHC.Types.IO Common.State
  {- Arity: 4, Strictness: <L,U(U)><L,U(1*U,U,U,U,U)><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Game.drawAndEnd2
                  `cast`
                (<GHC.Types.Int>_R
                 ->_R <Common.State>_R
                 ->_R <Common.Player>_R
                 ->_R Sym (GHC.Types.N:IO[0] <Common.State>_R)) -}
50442d636d44d18a9146b0beacd431a4
  getNextPlayer :: Common.State -> Common.Player
  {- Arity: 1, Strictness: <S(SLLLS),U(1*U,A,A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (gs :: Common.State) ->
                 Game.check (Common.players gs) (Common.cur_player gs)) -}
9b571e587555490c79cffc034bd69ce2
  initGame :: GHC.Types.Int -> Common.State
  {- Arity: 1, Strictness: <L,1*U(U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case Game.$winitGame w of ww { (#,,,,#) ww1 ww2 ww3 ww4 ww5 ->
                 Common.State ww1 ww2 ww3 ww4 ww5 }) -}
a7ce67c1bef1a3bbf18cc36b8c05f9d5
  initGameWithPlayers :: [Common.Player] -> Common.State
  {- Arity: 1, Strictness: <L,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [Common.Player]) ->
                 case Game.$winitGame
                        (case GHC.List.$wlenAcc @ Common.Player w 0# of ww2 { DEFAULT ->
                         GHC.Types.I# ww2 }) of ww { (#,,,,#) ww1 ww2 ww3 ww4 ww5 ->
                 Common.State (Common.clearHands w) ww2 ww3 ww4 ww5 }) -}
b6630ac52ef1770a692b3a568933d954
  initialCardCount :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 7#) -}
b35ef53b5d5605997f07540c42371935
  pickNextAndPlay :: Common.State -> GHC.Types.IO Common.State
  {- Arity: 2, Strictness: <S(SLLLS),1*U(U,U,U,U,1*U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Game.pickNextAndPlay1
                  `cast`
                (<Common.State>_R ->_R Sym (GHC.Types.N:IO[0] <Common.State>_R)) -}
1b8145fef430b22fa361a0fdc4f55fcc
  pickNextAndPlay1 ::
    Common.State
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Common.State #)
  {- Arity: 2, Strictness: <S(SLLLS),1*U(U,U,U,U,1*U)><S,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Common.State)
                   (w1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case w of ww { Common.State ww1 ww2 ww3 ww4 ww5 ->
                 Game.$wpickNextAndPlay ww1 ww2 ww3 ww4 ww5 w1 }) -}
0257be8cfd23d39279aaaf2ef4bbd848
  pickNextPlayer :: Common.State -> GHC.Types.IO Common.State
  {- Arity: 2, Strictness: <L,1*U(U,U,U,U,1*U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Game.pickNextPlayer1
                  `cast`
                (<Common.State>_R ->_R Sym (GHC.Types.N:IO[0] <Common.State>_R)) -}
04405460e3b291f57ad90c52cb9cd106
  pickNextPlayer1 ::
    Common.State
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Common.State #)
  {- Arity: 2, Strictness: <L,1*U(U,U,U,U,1*U)><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (gs :: Common.State)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 (# eta,
                    case gs of wild { Common.State ds ds1 ds2 ds3 ds4 ->
                    Common.State ds ds1 ds2 ds3 (Game.check ds ds4) } #)) -}
cc31b4f2fb88e58f9a473b63a26cdd31
  playCard ::
    Common.Card
    -> Common.State -> GHC.Types.IO (Common.Action, Common.State)
  {- Arity: 3, Strictness: <S(SL),1*U(U,U)><L,U(U,U,U,U,U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Game.playCard1
                  `cast`
                (<Common.Card>_R
                 ->_R <Common.State>_R
                 ->_R Sym (GHC.Types.N:IO[0] <(Common.Action, Common.State)>_R)) -}
47aae9bf9837c1542be581163c81a593
  playCard1 ::
    Common.Card
    -> Common.State
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (Common.Action, Common.State) #)
  {- Arity: 3, Strictness: <S(SL),1*U(U,U)><L,U(U,U,U,U,U)><S,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Common.Card)
                   (w1 :: Common.State)
                   (w2 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case w of ww { Common.Card ww1 ww2 ->
                 Game.$wplayCard ww1 ww2 w1 w2 }) -}
356e5450b734452571633583c21963b3
  playCard2 ::
    Common.Card
    -> Common.State
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Common.State #)
  {- Arity: 3, Strictness: <L,U><L,1*U(1*U,U,U,1*U,U)><S,U>,
     Unfolding: (\ (card :: Common.Card)
                   (gs :: Common.State)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 (# eta,
                    case gs of wild { Common.State ds ds1 ds2 ds3 ds4 ->
                    let {
                      ds5 :: (Common.Hand, Common.Hand)
                      = case Common.$wtakeCards
                               (GHC.Types.: @ Common.Card card (GHC.Types.[] @ Common.Card))
                               (case ds4 of wild1 {
                                  Common.HPlayer ds6 ds7 -> ds7
                                  Common.AiPlayer ds6 ds7 -> ds7
                                  Common.NoPlayer ipv -> Common.hand1 }) of ww { (#,#) ww1 ww2 ->
                        (ww1, ww2) }
                    } in
                    let {
                      new_p :: Common.Player
                      = case ds4 of wild1 {
                          Common.HPlayer ds6 ds7
                          -> Common.HPlayer
                               ds6
                               (case ds5 of wild2 { (,) dscard newHand -> newHand })
                          Common.AiPlayer ds6 ds7
                          -> Common.AiPlayer
                               ds6
                               (case ds5 of wild2 { (,) dscard newHand -> newHand })
                          Common.NoPlayer ipv -> Game.drawAndEnd3 }
                    } in
                    Common.State
                      (GHC.Base.map
                         @ Common.Player
                         @ Common.Player
                         (\ (p' :: Common.Player) ->
                          case Common.$fEqPlayer_$c== p' ds4 of wild1 {
                            GHC.Types.False -> p' GHC.Types.True -> new_p })
                         ds)
                      ds1
                      ds2
                      (GHC.Base.++
                         @ Common.Card
                         ds3
                         (case ds5 of wild1 { (,) dscard newHand -> dscard }))
                      (case Common.$fEqPlayer_$c== ds4 ds4 of wild1 {
                         GHC.Types.False -> ds4 GHC.Types.True -> new_p }) } #)) -}
af5929bfab8d950efbdfa0160e27a7c9
  playCard3 :: GHC.Types.IO (Common.Action, Common.State)
  {- Strictness: x -}
8f1262fe89689d03677271f921db63ae
  playCurrentPlayer :: Common.State -> (Common.Action, Common.Card)
  {- Arity: 1, Strictness: <S(LLLLS),U(A,A,A,1*U,1*U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (gs :: Common.State) ->
                 Game.useSimpleStrategy gs (Game.topDCard gs) (Game.curHand gs)) -}
fb57003a9340ac00b9601110af0a3257
  playLoop ::
    Common.State -> Common.Attack -> GHC.Types.IO Common.State
  {- Arity: 3, Strictness: <S(LLLLS),U(U,U,U,U,U)><L,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Game.attackAndPlay2
                  `cast`
                (<Common.State>_R
                 ->_R <Common.Attack>_R
                 ->_R Sym (GHC.Types.N:IO[0] <Common.State>_R)) -}
c650ca98c964601dd4c85f8ddf70440a
  playLoopNext ::
    Common.State -> Common.Action -> GHC.Types.IO Common.State
  {- Arity: 3, Strictness: <S(SLLLS),1*U(U,U,U,U,1*U)><S,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Game.playLoopNext1
                  `cast`
                (<Common.State>_R
                 ->_R <Common.Action>_R
                 ->_R Sym (GHC.Types.N:IO[0] <Common.State>_R)) -}
49fe15ca54263655cdc88193c96bf005
  playLoopNext1 ::
    Common.State
    -> Common.Action
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Common.State #)
  {- Arity: 3, Strictness: <S(SLLLS),1*U(U,U,U,U,1*U)><S,1*U><S,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Common.State)
                   (w1 :: Common.Action)
                   (w2 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case w of ww { Common.State ww1 ww2 ww3 ww4 ww5 ->
                 Game.$wplayLoopNext ww1 ww2 ww3 ww4 ww5 w1 w2 }) -}
fd3c2d6fabee4373660c80457d3d5fe8
  playOneCard ::
    Common.State -> GHC.Types.IO (Common.Action, Common.State)
  {- Arity: 2, Strictness: <S(LLLLS),U(U,U,U,U,U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Game.playOneCard1
                  `cast`
                (<Common.State>_R
                 ->_R Sym (GHC.Types.N:IO[0] <(Common.Action, Common.State)>_R)) -}
0382b4f506e40dc610fc9ebf48876f83
  playOneCard1 ::
    Common.State
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (Common.Action, Common.State) #)
  {- Arity: 2, Strictness: <S(LLLLS),U(U,U,U,U,U)><S,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Common.State)
                   (w1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case w of ww { Common.State ww1 ww2 ww3 ww4 ww5 ->
                 Game.$wplayOneCard ww1 ww2 ww3 ww4 ww5 w1 }) -}
ef5c8b08a1f8940c2d505b838b97f415
  playOneCard2 ::
    Common.Action
    -> Common.Card
    -> Common.State
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (Common.Action, Common.State) #)
  {- Arity: 4, Strictness: <S,1*U><L,U(U,U)><L,U(U,U,U,U,U)><S,U> -}
65bda7aace21f632e302be5c92da55d5
  playPlayer ::
    Common.State
    -> Common.Attack -> GHC.Types.IO (Common.Action, Common.State)
  {- Arity: 3, Strictness: <L,U(U,U,U,U,U)><S,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Game.playPlayer1
                  `cast`
                (<Common.State>_R
                 ->_R <Common.Attack>_R
                 ->_R Sym (GHC.Types.N:IO[0] <(Common.Action, Common.State)>_R)) -}
a7fb05ac3c8b548ff0e05344fce1abe8
  playPlayer1 ::
    Common.State
    -> Common.Attack
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (Common.Action, Common.State) #)
  {- Arity: 3, Strictness: <L,U(U,U,U,U,U)><S,1*U><S,U>,
     Unfolding: (\ (gs :: Common.State)
                   (under_attack :: Common.Attack)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case under_attack of wild {
                   Common.NoAttack
                   -> case gs of ww { Common.State ww1 ww2 ww3 ww4 ww5 ->
                      case Game.$wplayOneCard
                             ww1
                             ww2
                             ww3
                             ww4
                             ww5
                             eta of ds1 { (#,#) ipv ipv1 ->
                      case ipv1 of wild1 { (,) next_action gs' ->
                      case GHC.List.elem
                             @ Common.Action
                             Common.$fEqAction
                             next_action
                             Game.playPlayer5 of wild2 {
                        GHC.Types.False
                        -> case Game.playPlayer4
                           ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                     (Common.Action, Common.State) #)
                           of {}
                        GHC.Types.True -> ds1 } } } }
                   Common.Skip -> (# eta, (Common.EndTurn, gs) #)
                   Common.Draw2
                   -> case Game.drawAndEnd2
                             Game.playPlayer3
                             gs
                             (case gs of wild1 { Common.State ds1 ds2 ds3 ds4 ds5 -> ds5 })
                             eta of ds1 { (#,#) ipv ipv1 ->
                      (# ipv, (Common.EndTurn, ipv1) #) }
                   Common.Draw4
                   -> case Game.drawAndEnd2
                             Game.playPlayer2
                             gs
                             (case gs of wild1 { Common.State ds1 ds2 ds3 ds4 ds5 -> ds5 })
                             eta of ds1 { (#,#) ipv ipv1 ->
                      (# ipv, (Common.EndTurn, ipv1) #) } }) -}
f5a860ca79ed56bc5c1e1cf3601a9e77
  playPlayer2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 4#) -}
86fedfe59898da303677093d826179d7
  playPlayer3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 2#) -}
24f1859eaf4131e8d2fb7f70967505d3
  playPlayer4 :: GHC.Types.IO (Common.Action, Common.State)
  {- Strictness: x -}
62c0b16966119b2ef285f9741bef563d
  playPlayer5 :: [Common.Action]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Common.Action
                   Common.EndTurn
                   Game.playPlayer6) -}
35161a75a0b389254afc652808c1fa29
  playPlayer6 :: [Common.Action]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Common.Action
                   Common.AttackReverse
                   Game.playPlayer7) -}
07653131b44523c50fbb6ba5d5d80f4a
  playPlayer7 :: [Common.Action]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Common.Action
                   Common.AttackSkip
                   Game.playPlayer8) -}
cdb072c2b3c131d430119dd217578a91
  playPlayer8 :: [Common.Action]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Common.Action
                   Common.AttackDraw2
                   Game.playPlayer9) -}
ad402686185cd5f17d0f13fdd6160468
  playPlayer9 :: [Common.Action]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Common.Action
                   Common.AttackWildDraw4
                   (GHC.Types.[] @ Common.Action)) -}
6478d3c0a8cc2a5afd7d682c32009565
  playTurn ::
    Common.State -> GHC.Types.IO (Common.Action, Common.State)
  {- Arity: 2, Strictness: <S(LLLLS),U(U,U,U,U,U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Game.playOneCard1
                  `cast`
                (<Common.State>_R
                 ->_R Sym (GHC.Types.N:IO[0] <(Common.Action, Common.State)>_R)) -}
55ebbaa353de252606c21f7c990847b3
  playerHasWon :: Common.State -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S(LLLLS),1*U(A,A,A,A,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Common.State) ->
                 case w of ww { Common.State ww1 ww2 ww3 ww4 ww5 ->
                 Game.$wplayerHasWon ww5 }) -}
9e9cde183a6ec94a22fc83cd3095319d
  playerIsOut :: Common.State -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S(LLLLS),1*U(A,A,A,A,1*U)>,
     Unfolding: InlineRule (0, True, True) Game.playerHasWon -}
b2618ed0c33a178e614228695c7ed561
  reloadDeck :: Common.State -> GHC.Types.IO Common.State
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U,U,A,U,U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Game.reloadDeck1
                  `cast`
                (<Common.State>_R ->_R Sym (GHC.Types.N:IO[0] <Common.State>_R)) -}
e6fdc2892bd5b293f3a8194f60fdaa10
  reloadDeck1 ::
    Common.State
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Common.State #)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U,U,A,U,U)><S,U>,
     Unfolding: (\ (gs :: Common.State)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 (# eta,
                    case gs of wild { Common.State ds ds1 ds2 ds3 ds4 ->
                    Common.State
                      ds
                      ds1
                      (case GHC.List.$wlenAcc @ Common.Card ds3 0# of ww2 { DEFAULT ->
                       let {
                         y :: GHC.Prim.Int# = GHC.Prim.-# ww2 1#
                       } in
                       case GHC.Prim.tagToEnum#
                              @ GHC.Types.Bool
                              (GHC.Prim.<# 0# y) of wild1 {
                         GHC.Types.False -> GHC.Types.[] @ Common.Card
                         GHC.Types.True -> GHC.List.$wunsafeTake @ Common.Card y ds3 } })
                      (case GHC.List.$wlenAcc @ Common.Card ds3 0# of ww2 { DEFAULT ->
                       let {
                         x :: GHC.Prim.Int# = GHC.Prim.-# ww2 1#
                       } in
                       case GHC.Prim.tagToEnum#
                              @ GHC.Types.Bool
                              (GHC.Prim.<=# x 0#) of wild1 {
                         GHC.Types.False -> Game.$wunsafeDrop1 @ Common.Card x ds3
                         GHC.Types.True -> ds3 } })
                      ds4 } #)) -}
8a98f7061bf0ce75fd919f1796f51926
  restartGame :: Common.State -> GHC.Types.IO Common.State
  {- Arity: 2, Strictness: <L,1*U(1*U,A,A,A,A)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Game.restartGame1
                  `cast`
                (<Common.State>_R ->_R Sym (GHC.Types.N:IO[0] <Common.State>_R)) -}
b4c262204871a0da1a30f05d1c977d95
  restartGame1 ::
    Common.State
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Common.State #)
  {- Arity: 2, Strictness: <L,1*U(1*U,A,A,A,A)><S,U>,
     Unfolding: (\ (gs :: Common.State)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 let {
                   pa :: [Common.Player]
                   = case gs of wild { Common.State ds1 ds2 ds3 ds4 ds5 -> ds1 }
                 } in
                 case Game.$winitGame
                        (case GHC.List.$wlenAcc @ Common.Player pa 0# of ww2 { DEFAULT ->
                         GHC.Types.I# ww2 }) of ww { (#,,,,#) ww1 ww2 ww3 ww4 ww5 ->
                 case (System.Random.Shuffle.shuffleM
                         @ GHC.Types.IO
                         @ Common.Card
                         Control.Monad.Random.$fMonadRandomIO
                         (Game.$wunsafeDrop2 @ Common.Card 29# ww3))
                        `cast`
                      (GHC.Types.N:IO[0] <[Common.Card]>_R)
                        s of ds7 { (#,#) ipv ipv1 ->
                 let {
                   ww6 :: [Common.Player] = Game.deal ww3 (Common.clearHands pa)
                 } in
                 Game.$wplayLoop
                   ww6
                   ww2
                   ipv1
                   (Game.discard ww4 ww3)
                   (Game.check ww6 Common.noPlayer)
                   Common.NoAttack
                   ipv } }) -}
462504acea6646ccf1f8a78123135006
  reverseAndPlay :: Common.State -> GHC.Types.IO Common.State
  {- Arity: 2, Strictness: <S(SLLLS),1*U(1*U,U,U,U,1*U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Game.reverseAndPlay1
                  `cast`
                (<Common.State>_R ->_R Sym (GHC.Types.N:IO[0] <Common.State>_R)) -}
56f85de907977477777d80fa11dde7bd
  reverseAndPlay1 ::
    Common.State
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Common.State #)
  {- Arity: 2, Strictness: <S(SLLLS),1*U(1*U,U,U,U,1*U)><S,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Common.State)
                   (w1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case w of ww { Common.State ww1 ww2 ww3 ww4 ww5 ->
                 Game.$wreverseAndPlay ww1 ww2 ww3 ww4 ww5 w1 }) -}
16eb9f561c098a2d540987cd7454fe65
  reversePlayers :: Common.State -> GHC.Types.IO Common.State
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*U,U,U,U,U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Game.reversePlayers1
                  `cast`
                (<Common.State>_R ->_R Sym (GHC.Types.N:IO[0] <Common.State>_R)) -}
474ec5c7390fd5e1613b1ad21412a88e
  reversePlayers1 ::
    Common.State
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Common.State #)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*U,U,U,U,U)><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (gs :: Common.State)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 (# eta,
                    case gs of wild { Common.State ds ds1 ds2 ds3 ds4 ->
                    Common.State
                      (GHC.List.reverse1
                         @ Common.Player
                         ds
                         (GHC.Types.[] @ Common.Player))
                      ds1
                      ds2
                      ds3
                      ds4 } #)) -}
e5c195148981f86b96b59463a313244d
  setupGame :: Common.State -> GHC.Types.IO Common.State
  {- Arity: 2, Strictness: <S(LLSLL),1*U(1*U,U,U,1*U,A)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Game.setupGame1
                  `cast`
                (<Common.State>_R ->_R Sym (GHC.Types.N:IO[0] <Common.State>_R)) -}
d8a3005365c935e847b8e6b18e15d46b
  setupGame1 ::
    Common.State
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Common.State #)
  {- Arity: 2, Strictness: <S(LLSLL),1*U(1*U,U,U,1*U,A)><S,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Common.State)
                   (w1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case w of ww { Common.State ww1 ww2 ww3 ww4 ww5 ->
                 Game.$wsetupGame ww1 ww2 ww3 ww4 w1 }) -}
219c62e5cffe1a8fc3cfcf79ec2ee39a
  startGame :: Common.State -> GHC.Types.IO Common.State
  {- Arity: 2, Strictness: <S(SLLLS),1*U(U,U,U,U,1*U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Game.pickNextAndPlay1
                  `cast`
                (<Common.State>_R ->_R Sym (GHC.Types.N:IO[0] <Common.State>_R)) -}
425b4a282cf31cbc783dd01f70c950a2
  takeAction ::
    Common.Action
    -> Common.Card
    -> Common.State
    -> GHC.Types.IO (Common.Action, Common.State)
  {- Arity: 4, Strictness: <S,1*U><L,U(U,U)><L,U(U,U,U,U,U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Game.playOneCard2
                  `cast`
                (<Common.Action>_R
                 ->_R <Common.Card>_R
                 ->_R <Common.State>_R
                 ->_R Sym (GHC.Types.N:IO[0] <(Common.Action, Common.State)>_R)) -}
86648f8fa6849d478cc547d54d1a3a3f
  takeFromDeck ::
    Common.State -> GHC.Types.IO (Common.Action, Common.State)
  {- Arity: 2, Strictness: <L,U(U,U,U,U,U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Game.takeFromDeck1
                  `cast`
                (<Common.State>_R
                 ->_R Sym (GHC.Types.N:IO[0] <(Common.Action, Common.State)>_R)) -}
cd651148ea715c3df4a19c51dbcf00cf
  takeFromDeck1 ::
    Common.State
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (Common.Action, Common.State) #)
  {- Arity: 2, Strictness: <L,U(U,U,U,U,U)><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (gs :: Common.State)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case Game.drawAndEnd2
                        Game.takeFromDeck2
                        gs
                        (case gs of wild { Common.State ds1 ds2 ds3 ds4 ds5 -> ds5 })
                        s of ds1 { (#,#) ipv ipv1 ->
                 (# ipv, (Common.EndTurn, ipv1) #) }) -}
5a8c1010b89f96a10ce8911680b33de3
  takeFromDeck2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1#) -}
0b982363cdbfc85e86e10ca4a572b64e
  takeFromHand ::
    Common.Card -> Common.State -> GHC.Types.IO Common.State
  {- Arity: 3, Strictness: <L,U><L,1*U(1*U,U,U,1*U,U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Game.playCard2
                  `cast`
                (<Common.Card>_R
                 ->_R <Common.State>_R
                 ->_R Sym (GHC.Types.N:IO[0] <Common.State>_R)) -}
dd55f3339ecc49d0beeebf7e0dbd3afd
  takeFromHandWithAction ::
    Common.Card
    -> Common.Action
    -> Common.State
    -> GHC.Types.IO (Common.Action, Common.State)
  {- Arity: 4, Strictness: <L,U><L,U><L,1*U(1*U,U,U,1*U,U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Game.takeFromHandWithAction1
                  `cast`
                (<Common.Card>_R
                 ->_R <Common.Action>_R
                 ->_R <Common.State>_R
                 ->_R Sym (GHC.Types.N:IO[0] <(Common.Action, Common.State)>_R)) -}
12a708c65a3b93adeef5c3b1e68a5c50
  takeFromHandWithAction1 ::
    Common.Card
    -> Common.Action
    -> Common.State
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (Common.Action, Common.State) #)
  {- Arity: 4, Strictness: <L,U><L,U><L,1*U(1*U,U,U,1*U,U)><S,U>,
     Unfolding: InlineRule (4, True, False)
                (\ (card :: Common.Card)
                   (next_action :: Common.Action)
                   (gs :: Common.State)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case Game.playCard2 card gs eta of ds1 { (#,#) ipv ipv1 ->
                 (# ipv, (next_action, ipv1) #) }) -}
b9171f348e3ae3fee09f39fe53be8e62
  takeNextAction ::
    Common.Action
    -> Common.State
    -> Common.Attack
    -> GHC.Types.IO (Common.Action, Common.State)
  {- Arity: 4, Strictness: <L,U><L,U><L,A><S,U>,
     Unfolding: InlineRule (0, True, True)
                Game.takeNextAction1
                  `cast`
                (<Common.Action>_R
                 ->_R <Common.State>_R
                 ->_R <Common.Attack>_R
                 ->_R Sym (GHC.Types.N:IO[0] <(Common.Action, Common.State)>_R)) -}
73945ba8c787b0d3eba17bc3091192e6
  takeNextAction1 ::
    Common.Action
    -> Common.State
    -> Common.Attack
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (Common.Action, Common.State) #)
  {- Arity: 4, Strictness: <L,U><L,U><L,A><S,U>,
     Unfolding: InlineRule (4, True, False)
                (\ (next_action :: Common.Action)
                   (gs :: Common.State)
                   (under_attack :: Common.Attack)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case GHC.List.elem
                        @ Common.Action
                        Common.$fEqAction
                        next_action
                        Game.playPlayer5 of wild {
                   GHC.Types.False
                   -> case Game.playPlayer4
                      ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                (Common.Action, Common.State) #)
                      of {}
                   GHC.Types.True -> (# eta, (next_action, gs) #) }) -}
73b7fbef00150172ef11c83cfe524b33
  topDCard :: Common.State -> Common.Card
  {- Arity: 1, Strictness: <S(LLLSL),1*U(A,A,A,1*U,A)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Common.State) ->
                 case w of ww { Common.State ww1 ww2 ww3 ww4 ww5 ->
                 Game.$wtopDCard ww4 }) -}
591b21a806294f8c2a6151b6ed6c41fb
  updateCurHand ::
    Common.State -> Common.Hand -> GHC.Types.IO Common.State
  {- Arity: 3, Strictness: <L,U(1*U,U,U,U,U)><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Game.updateCurHand1
                  `cast`
                (<Common.State>_R
                 ->_R <Common.Hand>_R
                 ->_R Sym (GHC.Types.N:IO[0] <Common.State>_R)) -}
f999c709a78550b062f374364f0efaed
  updateCurHand1 ::
    Common.State
    -> Common.Hand
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Common.State #)
  {- Arity: 3, Strictness: <L,U(1*U,U,U,U,U)><L,U><S,U>,
     Unfolding: (\ (gs :: Common.State)
                   (h :: Common.Hand)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 let {
                   cp :: Common.Player
                   = case gs of wild { Common.State ds1 ds2 ds3 ds4 ds5 -> ds5 }
                 } in
                 Game.drawAndEnd4
                   gs
                   cp
                   (case cp of wild {
                      Common.HPlayer ds ds1 -> Common.HPlayer ds h
                      Common.AiPlayer ds ds1 -> Common.AiPlayer ds h
                      Common.NoPlayer ipv -> Game.drawAndEnd3 })
                   eta) -}
a2b025317cd6ce2f7eea4e0d022243e5
  updateCurPlayer ::
    Common.State -> Common.Player -> GHC.Types.IO Common.State
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(U,U,U,U,A)><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Game.updateCurPlayer1
                  `cast`
                (<Common.State>_R
                 ->_R <Common.Player>_R
                 ->_R Sym (GHC.Types.N:IO[0] <Common.State>_R)) -}
ff108b7ddaa2995be87aa558a1914f1b
  updateCurPlayer1 ::
    Common.State
    -> Common.Player
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Common.State #)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(U,U,U,U,A)><L,U><S,U>,
     Unfolding: InlineRule (3, True, False)
                (\ (gs :: Common.State)
                   (player :: Common.Player)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 (# eta,
                    case gs of wild { Common.State ds ds1 ds2 ds3 ds4 ->
                    Common.State ds ds1 ds2 ds3 player } #)) -}
7a22e49b14672965b81a5fc748f668f6
  updateDeck ::
    Common.State -> Common.Deck -> GHC.Types.IO Common.State
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(U,U,A,U,U)><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Game.updateDeck1
                  `cast`
                (<Common.State>_R
                 ->_R <Common.Deck>_R
                 ->_R Sym (GHC.Types.N:IO[0] <Common.State>_R)) -}
b8099eb26ca03e6382ef4456116ec553
  updateDeck1 ::
    Common.State
    -> Common.Deck
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Common.State #)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(U,U,A,U,U)><L,U><S,U>,
     Unfolding: InlineRule (3, True, False)
                (\ (gs :: Common.State)
                   (deck' :: Common.Deck)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 (# eta,
                    case gs of wild { Common.State ds ds1 ds2 ds3 ds4 ->
                    Common.State ds ds1 deck' ds3 ds4 } #)) -}
f42f1b51e5e0e1ad3d02d1e595cf2bbc
  updateDiscardS ::
    Common.State -> Common.Deck -> GHC.Types.IO Common.State
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(U,U,U,A,U)><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Game.updateDiscardS1
                  `cast`
                (<Common.State>_R
                 ->_R <Common.Deck>_R
                 ->_R Sym (GHC.Types.N:IO[0] <Common.State>_R)) -}
7836f98174ec7b6ab5d2d958449000c1
  updateDiscardS1 ::
    Common.State
    -> Common.Deck
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Common.State #)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(U,U,U,A,U)><L,U><S,U>,
     Unfolding: InlineRule (3, True, False)
                (\ (gs :: Common.State)
                   (d_stack' :: Common.Deck)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 (# eta,
                    case gs of wild { Common.State ds ds1 ds2 ds3 ds4 ->
                    Common.State ds ds1 ds2 d_stack' ds4 } #)) -}
da45ea61191997fd308bda4810fad7ad
  updateHand ::
    Common.Player -> Common.Hand -> GHC.Types.IO Common.Player
  {- Arity: 3, Strictness: <L,1*U><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Game.updateHand1
                  `cast`
                (<Common.Player>_R
                 ->_R <Common.Hand>_R
                 ->_R Sym (GHC.Types.N:IO[0] <Common.Player>_R)) -}
d1278cfddb1edd3ccf9bd3e4e65adc2f
  updateHand1 ::
    Common.Player
    -> Common.Hand
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Common.Player #)
  {- Arity: 3, Strictness: <L,1*U><L,U><S,U>,
     Unfolding: InlineRule (3, True, False)
                (\ (player :: Common.Player)
                   (h :: Common.Hand)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 (# eta,
                    case player of wild {
                      Common.HPlayer ds ds1 -> Common.HPlayer ds h
                      Common.AiPlayer ds ds1 -> Common.AiPlayer ds h
                      Common.NoPlayer ipv -> Game.drawAndEnd3 } #)) -}
df03d42244f5eda6707c83ae22366956
  updatePlayer ::
    Common.State
    -> Common.Player -> Common.Player -> GHC.Types.IO Common.State
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(1*U,U,U,U,U)><L,U><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Game.drawAndEnd4
                  `cast`
                (<Common.State>_R
                 ->_R <Common.Player>_R
                 ->_R <Common.Player>_R
                 ->_R Sym (GHC.Types.N:IO[0] <Common.State>_R)) -}
ebad632e14ad419bc9c7ea29d5eba9b7
  useSimpleStrategy ::
    Common.State
    -> Common.Card -> Common.Hand -> (Common.Action, Common.Card)
  {- Arity: 3, Strictness: <L,A><L,U(U,U)><S,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Common.State) (w1 :: Common.Card) (w2 :: Common.Hand) ->
                 case Game.$wuseSimpleStrategy w1 w2 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

